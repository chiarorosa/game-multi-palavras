<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Jogo de Palavras - Muerte Mexicana</title>
    <style>
      body {
        font-family: "Arial", sans-serif;
        background-color: #1e002d; /* Roxo bem escuro, quase preto */
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        color: #f8f8f8; /* Texto padrão claro para contraste com fundo escuro */
        overflow-x: hidden;
      }

      #game-container {
        width: 95%;
        max-width: 900px;
        min-height: 600px;
        background: #2c0b3f; /* Roxo escuro para o container */
        border-radius: 20px;
        box-shadow: 0 0 30px rgba(255, 0, 153, 0.5),
          0 0 15px rgba(0, 188, 212, 0.5); /* Sombra neon */
        padding: 20px;
        display: grid;
        grid-template-areas:
          "top-area top-area top-area"
          "left-sidebar middle-area middle-area"
          "left-sidebar bottom-area bottom-area";
        grid-template-columns: 150px 1fr;
        grid-template-rows: auto 1fr auto;
        gap: 15px;
        position: relative;
        border: 2px solid #ff0099; /* Borda rosa choque */
      }

      /* --- ÁREA SUPERIOR --- */
      #top-area {
        grid-area: top-area;
        display: flex;
        justify-content: space-around;
        align-items: center;
        padding: 10px;
        background-color: rgba(0, 0, 0, 0.2); /* Fundo sutilmente escuro */
        border-radius: 15px;
        margin-bottom: 10px;
      }

      .info-panel {
        padding: 10px 15px;
        border-radius: 10px;
        text-align: center;
        box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.4),
          0 0 5px rgba(255, 255, 255, 0.2);
        min-width: 80px;
        border: 1px solid rgba(255, 255, 255, 0.3);
      }
      .info-panel .title {
        font-size: 0.8em;
        margin-bottom: 5px;
        font-weight: bold;
      }
      .info-panel .value {
        font-size: 1.8em;
        font-weight: bold;
      }

      #points-panel {
        background-color: #ff0099; /* Rosa Choque */
        color: #ffffff;
      }
      #multis-panel {
        background-color: #ff6f00; /* Laranja Vibrante */
        color: #ffffff;
      }
      #score-panel {
        background-color: #ffc107; /* Amarelo Dourado */
        color: #1e002d; /* Texto escuro para contraste com amarelo */
      }
      #energy-panel {
        background-color: #00bcd4; /* Turquesa */
        color: #ffffff;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      #energy-panel .value {
        font-size: 2.2em;
      }
      #energy-panel .icon {
        font-size: 1em;
        color: #ffeb3b;
      }

      #top-area > span.multiplier-symbol {
        font-size: 2em;
        font-weight: bold;
        color: #f8f8f8;
        margin: 0 5px;
      }

      #score-panel .value-container {
        position: relative;
      }
      #score-panel .score-target {
        font-size: 0.7em;
        color: #4a0f5c; /* Roxo escuro no amarelo */
      }

      /* --- ÁREA LATERAL ESQUERDA --- */
      #left-sidebar {
        grid-area: left-sidebar;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px;
        gap: 15px;
      }
      #left-sidebar button {
        padding: 10px;
        width: 100px;
        border-radius: 8px;
        border: 1px solid #76ff03; /* Borda verde limão */
        cursor: pointer;
        font-size: 1em;
        background-color: #2c0b3f; /* Fundo roxo escuro */
        color: #76ff03; /* Texto verde limão */
        box-shadow: 0 0 8px rgba(118, 255, 3, 0.5);
        transition: background-color 0.2s, color 0.2s, box-shadow 0.2s;
        font-weight: bold;
      }
      #left-sidebar button:hover:not(:disabled) {
        background-color: #76ff03;
        color: #1e002d;
        box-shadow: 0 0 12px rgba(118, 255, 3, 0.8);
      }
      #left-sidebar button:disabled {
        background-color: #4a2b5e;
        color: #6c4b7e;
        border-color: #6c4b7e;
        box-shadow: none;
        cursor: not-allowed;
        opacity: 0.7;
      }
      #swap-letters-button span {
        font-weight: bold;
        color: #ffeb3b; /* Destaque amarelo para custo */
      }
      #menu-button {
        font-size: 1.5em;
        border-color: #00bcd4; /* Turquesa */
        color: #00bcd4;
      }
      #menu-button:hover:not(:disabled) {
        background-color: #00bcd4;
        color: #1e002d;
      }

      /* --- ÁREA CENTRAL --- */
      #middle-area {
        grid-area: middle-area;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 10px;
        gap: 20px;
      }

      #board {
        display: flex;
        gap: 5px;
        background-color: #1a0823; /* Roxo ainda mais escuro para o tabuleiro */
        padding: 10px;
        border-radius: 10px;
        border: 1px solid #ff0099;
      }

      .board-slot {
        width: 50px;
        height: 50px;
        background-color: #f8f0f0; /* Base clara para os slots (papel) */
        border: 2px dashed #ff6f00; /* Borda tracejada laranja */
        border-radius: 5px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.5em;
        font-weight: bold;
        position: relative;
        color: #1e002d; /* Texto escuro no slot */
        transition: background-color 0.2s, border-color 0.2s;
      }
      .board-slot.has-letter {
        border-style: solid;
        border-color: #ff0099; /* Borda rosa quando tem letra */
        background-color: #fff8f8;
      }

      .board-slot .bonus-pip {
        position: absolute;
        bottom: 2px;
        right: 2px;
        width: 10px; /* Pips maiores */
        height: 10px;
        border-radius: 50%;
        border: 1px solid #1e002d; /* Contorno escuro no pip */
      }
      .bonus-pip.point {
        background-color: #00bcd4;
      } /* Turquesa */
      .bonus-pip.multi {
        background-color: #ff6f00;
      } /* Laranja */

      #play-button {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background-color: #ff0099; /* Rosa choque */
        color: white;
        font-size: 2.5em;
        border: 2px solid white;
        cursor: pointer;
        box-shadow: 0 0 15px rgba(255, 0, 153, 0.7);
        transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      #play-button:hover:not(:disabled) {
        background-color: #e00080;
        box-shadow: 0 0 20px rgba(255, 0, 153, 1);
      }
      #play-button:active:not(:disabled) {
        transform: scale(0.95);
      }
      #play-button:disabled {
        background-color: #7c004c;
        border-color: #b86fa0;
        box-shadow: none;
        cursor: not-allowed;
        opacity: 0.7;
      }

      /* --- ÁREA INFERIOR --- */
      #bottom-area {
        grid-area: bottom-area;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px 0; /* Ajustado padding */
        gap: 10px;
      }

      #rules-area {
        background-color: rgba(26, 8, 35, 0.7);
        color: #f8f0f0;
        padding: 8px 12px;
        border-radius: 8px;
        margin-bottom: 10px;
        border: 1px solid #ffc107;
        box-shadow: 0 0 8px rgba(255, 193, 7, 0.4);
        text-align: left;
        max-width: 90%;
      }
      #rules-area ul {
        list-style-type: none;
        padding-left: 0;
        margin: 0;
        font-size: 0.8em;
      }
      #rules-area li {
        margin-bottom: 4px;
        color: #f0c5ff;
      }
      #rules-area li:last-child {
        margin-bottom: 0;
      }
      #rules-area li strong {
        color: #ffeb3b;
      }

      #hand-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
      }
      #hand-controls button {
        padding: 8px 12px;
        border-radius: 5px;
        border: 1px solid #ffc107; /* Borda Amarela */
        background-color: #2c0b3f; /* Fundo Roxo Escuro */
        color: #ffc107; /* Texto Amarelo */
        cursor: pointer;
        font-size: 0.9em;
        box-shadow: 0 0 8px rgba(255, 193, 7, 0.5);
        font-weight: bold;
      }
      #hand-controls button:hover:not(:disabled) {
        background-color: #ffc107;
        color: #1e002d;
      }
      #hand-controls button:disabled {
        background-color: #4a2b5e;
        color: #8c6b9e;
        border-color: #8c6b9e;
        box-shadow: none;
      }

      #player-hand {
        display: flex;
        gap: 5px;
        padding: 10px;
        background-color: #1a0823; /* Fundo da mão - Roxo bem escuro */
        border-radius: 10px;
        min-height: 70px;
        flex-wrap: wrap;
        justify-content: center;
        transition: background-color 0.2s;
        border: 1px solid #76ff03; /* Borda verde limão */
      }

      .letter-tile {
        width: 45px;
        height: 45px;
        background-color: #fefae0; /* Fundo osso/creme bem claro */
        border: 2px solid #00bcd4; /* Borda Turquesa */
        border-radius: 5px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 1.6em;
        font-weight: bold;
        color: #1e002d; /* Letra roxo escuro */
        cursor: grab;
        user-select: none;
        box-shadow: 0 0 5px rgba(0, 188, 212, 0.5);
        position: relative;
        transition: opacity 0.2s, transform 0.2s, box-shadow 0.2s;
      }
      .letter-tile:hover {
        box-shadow: 0 0 10px rgba(0, 188, 212, 0.8);
      }
      .letter-tile.dragging {
        opacity: 0.6;
        transform: scale(1.1);
        cursor: grabbing;
      }
      .letter-tile span.value {
        font-size: 0.5em;
        font-weight: bold;
        position: absolute;
        bottom: 2px;
        right: 4px;
        color: #ff6f00; /* Valor da letra laranja */
      }

      /* --- POPUP FIM DE JOGO --- */
      .popup {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #210733; /* Fundo roxo escuro para popup */
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 0 25px rgba(255, 0, 153, 0.6);
        text-align: center;
        z-index: 100;
        border: 2px solid #ffc107; /* Borda amarela */
        color: #f8f8f8;
      }
      .popup.hidden {
        display: none;
      }
      .popup h2 {
        margin-top: 0;
        color: #ff0099; /* Título Rosa */
        font-size: 2em;
      }
      .popup p {
        font-size: 1.2em;
        margin: 20px 0;
      }
      .popup strong {
        color: #ffeb3b;
      } /* Pontuação final em amarelo brilhante */
      .popup button {
        padding: 12px 25px;
        background-color: #76ff03; /* Botão verde limão */
        color: #1e002d; /* Texto escuro */
        border: none;
        border-radius: 8px;
        font-size: 1.1em;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.2s, transform 0.1s;
      }
      .popup button:hover {
        background-color: #64dd17;
      }
      .popup button:active {
        transform: scale(0.97);
      }

      .drag-over {
        background-color: #4a2b5e !important;
        border-color: #76ff03 !important; /* Verde Limão para drag over */
        box-shadow: inset 0 0 10px rgba(118, 255, 3, 0.5);
      }

      #message-area {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(255, 0, 153, 0.9); /* Rosa choque mais opaco */
        color: #ffffff; /* Texto branco puro para contraste */
        padding: 12px 25px; /* Mais padding */
        border-radius: 10px; /* Bordas mais arredondadas */
        font-size: 1.1em; /* Fonte maior */
        z-index: 1100; /* Garantir que está bem na frente */
        opacity: 0;
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        pointer-events: none;
        border: 2px solid #ffffff; /* Borda branca */
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); /* Sombra no texto */
      }
      #message-area.visible {
        opacity: 1;
        transform: translate(-50%, -10px);
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div id="top-area">
        <div id="points-panel" class="info-panel">
          <div class="title">Pontos</div>
          <div id="current-word-points" class="value">0</div>
        </div>
        <span class="multiplier-symbol">x</span>
        <div id="multis-panel" class="info-panel">
          <div class="title">Multis</div>
          <div id="current-word-multis" class="value">0</div>
        </div>
        <div id="score-panel" class="info-panel">
          <div class="title">Pontuação</div>
          <div class="value-container">
            <span id="total-score" class="value">0</span>
            <span class="score-target"
              >/<span id="score-target-value">60</span></span
            >
          </div>
        </div>
        <div id="energy-panel" class="info-panel">
          <span id="current-energy" class="value">3</span>
          <span class="icon">⚡</span>
        </div>
      </div>

      <div id="left-sidebar">
        <button id="menu-button" title="Menu (Não implementado)">☰</button>
        <button id="swap-letters-button" title="Trocar todas as letras da mão">
          Trocar <span id="swap-cost">1⚡</span>
        </button>
      </div>

      <div id="middle-area">
        <div id="board"></div>
        <button id="play-button" title="Validar Palavra">▶</button>
      </div>

      <div id="bottom-area">
        <div id="rules-area">
          <ul>
            <li>Valide palavras para ganhar <strong>PONTOS</strong>!</li>
            <li>
              Fim de jogo se <strong>ENERGIA</strong> chegar a
              <strong>0</strong>.
            </li>
            <li>Validar palavra: -1 <strong>ENERGIA</strong></li>
            <li>Trocar letras: -1 <strong>ENERGIA</strong></li>
            <li>
              Atingir a meta de <strong>PONTOS</strong>: +3
              <strong>ENERGIA</strong>!
            </li>
          </ul>
        </div>
        <div id="hand-controls">
          <button
            id="sort-alpha-button"
            title="Ordenar letras da mão alfabeticamente"
          >
            ABC
          </button>
          <button
            id="clear-word-button"
            title="Remover letras do tabuleiro para a mão"
          >
            Limpar
          </button>
        </div>
        <div
          id="player-hand"
          title="Arraste letras daqui para o tabuleiro ou do tabuleiro para cá"
        ></div>
      </div>

      <div id="game-over-popup" class="popup hidden">
        <h2>Fim de Jogo!</h2>
        <p>Sua pontuação final: <strong id="final-score">0</strong></p>
        <button id="restart-button">Jogar Novamente</button>
      </div>

      <div id="message-area">Mensagem aqui</div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const NUM_BOARD_SLOTS = 10;
        const NUM_HAND_SLOTS = 10;
        const INITIAL_ENERGY = 3;
        const SWAP_COST = 1;
        const MIN_VOWELS_IN_HAND = 3;
        const MAX_REFILL_ATTEMPTS = 30;

        const VOWELS = ["A", "E", "I", "O", "U"];

        const letterValues = {
          A: 1,
          E: 1,
          I: 1,
          O: 1,
          S: 1,
          U: 1,
          M: 2,
          R: 2,
          T: 2,
          D: 3,
          L: 3,
          C: 3,
          P: 3,
          N: 4,
          B: 4,
          Ç: 5,
          F: 5,
          G: 5,
          H: 5,
          V: 5,
          J: 6,
          Q: 8,
          X: 8,
          Z: 8,
        };
        const initialLetterBagDistribution = {
          A: 14,
          E: 11,
          I: 10,
          O: 10,
          S: 8,
          U: 7,
          M: 6,
          R: 6,
          T: 5,
          D: 5,
          L: 5,
          C: 4,
          P: 4,
          N: 4,
          B: 3,
          Ç: 2,
          F: 2,
          G: 2,
          H: 2,
          V: 2,
          J: 2,
          Q: 1,
          X: 1,
          Z: 1,
        };
        const boardBonusConfig = [
          { type: "point", value: 1 },
          { type: "multi", value: 1 },
          { type: "multi", value: 1 },
          { type: "multi", value: 1 },
          null,
          { type: "multi", value: 1 },
          null,
          { type: "point", value: 1 },
          null,
          { type: "multi", value: 1 },
        ];

        const dictionary = [
          // Objetos
          "MESA",
          "CADEIRA",
          "COPO",
          "PRATO",
          "FACA",
          "GARFO",
          "COLHER",
          "PANO",
          "LIVRO",
          "CADERNO",
          "LAPIZ",
          "CANETA",
          "REGUA",
          "CHAVE",
          "PORTA",
          "JANELA",
          "CAMA",
          "SOFA",
          "VASO",
          "BOLA",
          "CARRO",
          "BARCO",
          "TREM",
          "AVIAO",
          "RADIO",
          "TV",
          "CELULAR",
          "RELOGIO",
          "OCULOS",
          "SAPATO",
          "BOTA",
          "MEIA",
          "CAMISA",
          "CALCA",
          "SAIA",
          "VESTIDO",
          "ANEL",
          "COLAR",
          "QUADRO",
          "PENTE",
          "ESCOVA",
          "TOALHA",
          "BALDE",
          "CORDA",
          "RODA",
          "DADO",
          "CAIXA",
          "FITA",
          "PAPEL",
          "TINTA",
          "SINO",
          "APITO",
          "BONECA",
          "PINCEL",
          "TELHA",
          "TIJOLO",
          "PREGO",
          "PARAFUSO",

          // Frutas
          "MACA",
          "BANANA",
          "LARANJA",
          "LIMAO",
          "UVA",
          "PERA",
          "MORANGO",
          "MELAO",
          "MELANCIA",
          "ABACAXI",
          "MANGA",
          "MAMAO",
          "GOIABA",
          "CAJU",
          "ACEROLA",
          "FIGO",
          "PESSEGO",
          "AMEIXA",
          "CEREJA",
          "KIWI",
          "ROMA",
          "JACA",
          "PITANGA",
          "MARACUJA",
          "COCO",
          "ABACATE",
          "CACAU",
          "GUARANA",
          "ACAI",
          "CUPUACU",
          "CAQUI",
          "LICHIA",
          "MELOA",
          "AMORA",
          "FRAMBOESA",
          "MIRTILO",
          "GROSELHA",
          "KINO",
          "TAMARA",
          "CIRIGUELA",
          "UMBU",
          "JENIPAPO",
          "ATEMOIA",
          "GRAVIOLA",
          "SIRIGUELA",
          "TANGERINA",

          // Verbos (Infinitivo)
          "AMAR",
          "ANDAR",
          "ABRIR",
          "AJUDAR",
          "BEBER",
          "BUSCAR",
          "BRINCAR",
          "CAIR",
          "CANTAR",
          "CHAMAR",
          "COMER",
          "CORRER",
          "CORTAR",
          "COZINHAR",
          "CRIAR",
          "CUIDAR",
          "DANÇAR",
          "DAR",
          "DIZER",
          "DORMIR",
          "ENTRAR",
          "ESTUDAR",
          "FALAR",
          "FAZER",
          "FECHAR",
          "FICAR",
          "GANHAR",
          "GOSTAR",
          "GRITAR",
          "IR",
          "JOGAR",
          "LER",
          "LAVAR",
          "LEVAR",
          "MEXER",
          "MUDAR",
          "NADAR",
          "OUVIR",
          "OLHAR",
          "PAGAR",
          "PARTIR",
          "PASSAR",
          "PEDIR",
          "PENSAR",
          "PERDER",
          "PINTAR",
          "PODER",
          "PUXAR",
          "QUERER",
          "RIR",
          "SABER",
          "SAIR",
          "SENTIR",
          "SER",
          "SUBIR",
          "VENDER",
          "VER",
          "VIR",
          "VIVER",
          "VOAR",
          "VOLTAR",
          "USAR",
          "SONHAR",
          "PEGAR",
          "MORAR",
          "DEVER",
          "CRESCER",
          "CHEGAR",
          "BAILAR",
        ].filter((palavra) => palavra.length <= NUM_BOARD_SLOTS);

        let letterBag = [];
        let playerHand = [];
        let boardState = Array(NUM_BOARD_SLOTS).fill(null);
        let currentEnergy, totalScore, currentWordPoints, currentWordMultis;
        let draggedLetterInfo = null;
        let gameActive = true;
        let messageTimeout;
        let targetScore = 60;
        let scoreTargetValueElement;

        const boardElement = document.getElementById("board");
        const playerHandElement = document.getElementById("player-hand");
        const currentWordPointsElement = document.getElementById(
          "current-word-points"
        );
        const currentWordMultisElement = document.getElementById(
          "current-word-multis"
        );
        const totalScoreElement = document.getElementById("total-score");
        const currentEnergyElement = document.getElementById("current-energy");
        const playButton = document.getElementById("play-button");
        const swapLettersButton = document.getElementById(
          "swap-letters-button"
        );
        const clearWordButton = document.getElementById("clear-word-button");
        const sortAlphaButton = document.getElementById("sort-alpha-button");
        const gameOverPopup = document.getElementById("game-over-popup");
        const finalScoreElement = document.getElementById("final-score");
        const restartButton = document.getElementById("restart-button");
        const menuButton = document.getElementById("menu-button");
        const messageArea = document.getElementById("message-area");
        scoreTargetValueElement = document.getElementById("score-target-value");

        function isVowel(letter) {
          return VOWELS.includes(letter.toUpperCase());
        }
        function countVowelsInHand(handArray) {
          return handArray.reduce(
            (count, tile) => count + (tile && isVowel(tile.letter) ? 1 : 0),
            0
          );
        }

        function shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
          }
        }

        function createLetterBag() {
          letterBag = [];
          for (const letter in initialLetterBagDistribution) {
            for (let i = 0; i < initialLetterBagDistribution[letter]; i++)
              letterBag.push(letter);
          }
          shuffleArray(letterBag);
        }

        function generateUniqueId() {
          return (
            Date.now().toString(36) + Math.random().toString(36).substring(2)
          );
        }
        function showMessage(text, duration = 2000) {
          clearTimeout(messageTimeout);
          messageArea.textContent = text;
          messageArea.classList.add("visible");
          messageTimeout = setTimeout(
            () => messageArea.classList.remove("visible"),
            duration
          );
        }

        function renderBoard() {
          boardElement.innerHTML = "";
          boardState.forEach((slotContent, index) => {
            const slotDiv = document.createElement("div");
            slotDiv.classList.add("board-slot");
            slotDiv.dataset.index = index;
            if (slotContent) {
              const letterCharDiv = document.createElement("div");
              letterCharDiv.classList.add("letter-char");
              letterCharDiv.textContent = slotContent.letter;
              slotDiv.appendChild(letterCharDiv);
              slotDiv.classList.add("has-letter");
              slotDiv.draggable = true;
              const valueSpan = document.createElement("span");
              valueSpan.classList.add("value");
              valueSpan.textContent = letterValues[slotContent.letter];
              slotDiv.appendChild(valueSpan);
              slotDiv.addEventListener("dragstart", handleDragStartBoardLetter);
            }
            const bonus = boardBonusConfig[index];
            if (bonus) {
              const pip = document.createElement("div");
              pip.classList.add("bonus-pip", bonus.type);
              slotDiv.appendChild(pip);
            }
            slotDiv.addEventListener("dragover", handleDragOver);
            slotDiv.addEventListener("dragenter", handleDragEnter);
            slotDiv.addEventListener("dragleave", handleDragLeave);
            slotDiv.addEventListener("drop", handleDropOnBoardSlot);
            boardElement.appendChild(slotDiv);
          });
          calculateAndUpdateWordScore();
        }

        function renderHand() {
          playerHandElement.innerHTML = "";
          playerHand.forEach((tile) => {
            if (!tile) return;
            const tileDiv = document.createElement("div");
            tileDiv.classList.add("letter-tile");
            tileDiv.textContent = tile.letter;
            tileDiv.draggable = true;
            tileDiv.dataset.handId = tile.id;
            tileDiv.dataset.letter = tile.letter;
            const valueSpan = document.createElement("span");
            valueSpan.classList.add("value");
            valueSpan.textContent = letterValues[tile.letter];
            tileDiv.appendChild(valueSpan);
            tileDiv.addEventListener("dragstart", handleDragStartHandLetter);
            tileDiv.addEventListener("dragend", handleDragEndLetter);
            playerHandElement.appendChild(tileDiv);
          });
        }

        function renderStats() {
          currentWordPointsElement.textContent = currentWordPoints;
          currentWordMultisElement.textContent = currentWordMultis;
          totalScoreElement.textContent = totalScore;
          currentEnergyElement.textContent = currentEnergy;
          if (scoreTargetValueElement)
            scoreTargetValueElement.textContent = targetScore; // Atualiza aqui também

          const isBoardEmpty = boardState.every((s) => s === null);
          playButton.disabled = !gameActive || isBoardEmpty;
          clearWordButton.disabled = !gameActive || isBoardEmpty;
          swapLettersButton.disabled =
            !gameActive || currentEnergy < SWAP_COST || playerHand.length === 0;
          sortAlphaButton.disabled = !gameActive || playerHand.length === 0;
        }

        function drawLettersFromBag(count, bagSource) {
          const drawn = [];
          for (let i = 0; i < count; i++) {
            if (bagSource.length === 0) break;
            drawn.push(bagSource.pop());
          }
          return drawn.map((letter) => ({ letter, id: generateUniqueId() }));
        }

        function canFormWord(word, handLettersList) {
          const available = [...handLettersList];
          for (const char of word.toUpperCase()) {
            const index = available.indexOf(char);
            if (index === -1) return false;
            available.splice(index, 1);
          }
          return true;
        }

        function canFormAnyDictionaryWord(handTilesArray, dict) {
          if (!handTilesArray || handTilesArray.length === 0) return false;
          const handLetters = handTilesArray.map((tile) => tile.letter);
          for (const word of dict) {
            if (
              word.length <= handLetters.length &&
              canFormWord(word, handLetters)
            ) {
              return true;
            }
          }
          return false;
        }

        function refillHand() {
          let existingHandTiles = playerHand.filter(Boolean);

          for (let attempt = 0; attempt < MAX_REFILL_ATTEMPTS; attempt++) {
            let currentAttemptHandTiles = [...existingHandTiles];
            let tempLetterBag = [...letterBag];
            shuffleArray(tempLetterBag);

            const neededToComplete =
              NUM_HAND_SLOTS - currentAttemptHandTiles.length;
            if (neededToComplete > 0) {
              const drawnLettersForAttempt = drawLettersFromBag(
                neededToComplete,
                tempLetterBag
              );
              currentAttemptHandTiles.push(...drawnLettersForAttempt);
            }

            const hasEnoughVowels =
              countVowelsInHand(currentAttemptHandTiles) >= MIN_VOWELS_IN_HAND;
            const canFormWordFromDict = canFormAnyDictionaryWord(
              currentAttemptHandTiles,
              dictionary
            );

            if (
              currentAttemptHandTiles.length === NUM_HAND_SLOTS &&
              hasEnoughVowels &&
              canFormWordFromDict
            ) {
              playerHand = currentAttemptHandTiles;
              letterBag = tempLetterBag;
              renderHand();
              return;
            }
          }

          console.warn(
            `Não foi possível gerar mão com ${MIN_VOWELS_IN_HAND} vogais E palavra formável. Preenchendo da melhor forma possível.`
          );
          playerHand = existingHandTiles;
          const neededFinally = NUM_HAND_SLOTS - playerHand.length;
          if (neededFinally > 0) {
            const newLetters = drawLettersFromBag(neededFinally, letterBag);
            playerHand.push(...newLetters);
          }

          let currentVowels = countVowelsInHand(playerHand);
          let consonantsInHandIndices = [];
          playerHand.forEach((tile, index) => {
            if (tile && !isVowel(tile.letter))
              consonantsInHandIndices.push(index);
          });
          shuffleArray(consonantsInHandIndices);

          let availableVowelsInGlobalBag = letterBag.filter((l) => isVowel(l));
          shuffleArray(availableVowelsInGlobalBag);

          let replacedForVowelFallback = 0;
          while (
            currentVowels < MIN_VOWELS_IN_HAND &&
            consonantsInHandIndices.length > 0 &&
            availableVowelsInGlobalBag.length > 0 &&
            playerHand.length === NUM_HAND_SLOTS
          ) {
            const consIdx = consonantsInHandIndices.pop();
            const vowelToTake = availableVowelsInGlobalBag.pop();

            const globalBagVowelIdx = letterBag.indexOf(vowelToTake);
            if (globalBagVowelIdx > -1) letterBag.splice(globalBagVowelIdx, 1);
            else continue;

            const oldConsTile = playerHand[consIdx];
            letterBag.push(oldConsTile.letter);

            playerHand[consIdx] = {
              letter: vowelToTake,
              id: generateUniqueId(),
            };
            currentVowels++;
            replacedForVowelFallback++;
          }
          if (replacedForVowelFallback > 0) shuffleArray(letterBag);

          renderHand();
        }

        function calculateAndUpdateWordScore() {
          let points = 0;
          let multis = 0;
          let wordFormed = false;
          boardState.forEach((slotContent, index) => {
            if (slotContent) {
              wordFormed = true;
              points += letterValues[slotContent.letter];
              const bonus = boardBonusConfig[index];
              if (bonus) {
                if (bonus.type === "point") points += bonus.value;
                if (bonus.type === "multi") multis += bonus.value;
              }
            }
          });
          currentWordPoints = wordFormed ? points : 0;
          currentWordMultis = wordFormed ? multis : 0;
          renderStats();
        }

        function clearWordFromBoard() {
          if (!gameActive) return;
          let lettersMoved = false;
          for (let i = 0; i < boardState.length; i++) {
            if (boardState[i]) {
              playerHand.push(boardState[i]);
              boardState[i] = null;
              lettersMoved = true;
            }
          }
          if (lettersMoved) {
            renderBoard();
            sortHandAlpha();
            renderHand();
          }
        }

        function isValidWord(word) {
          if (word.length < 2) return false;
          return dictionary.includes(word.toUpperCase());
        }

        function handlePlayWord() {
          if (!gameActive) return;
          const word = boardState.map((s) => (s ? s.letter : "")).join("");
          if (word.length === 0) {
            showMessage("Forme uma palavra primeiro!", 1500);
            return;
          }

          if (isValidWord(word)) {
            const scoreFromWord = currentWordPoints * (1 + currentWordMultis);
            totalScore += scoreFromWord;
            currentEnergy -= 1;

            if (totalScore >= targetScore) {
              currentEnergy += 3;
              targetScore += 60;
              // scoreTargetValueElement.textContent = targetScore; // Já é atualizado em renderStats
              showMessage(
                `META ATINGIDA! +3 ENERGIA! Próxima meta: ${targetScore} pts`,
                3500
              );
            } else {
              showMessage(`"${word}" +${scoreFromWord} pts!`, 2000);
            }

            boardState.fill(null);
            refillHand();
            checkGameOver();
          } else {
            showMessage(`"${word}" não é válida!`, 2000);
          }
          renderBoard(); // Isso chama calculateAndUpdateWordScore que chama renderStats
        }

        function handleSwapLetters() {
          if (
            !gameActive ||
            currentEnergy < SWAP_COST ||
            playerHand.length === 0
          ) {
            showMessage(
              playerHand.length === 0 ? "Mão vazia!" : "Energia insuficiente!",
              1500
            );
            return;
          }
          currentEnergy -= SWAP_COST;
          playerHand.forEach((tile) => {
            if (tile) letterBag.push(tile.letter);
          });
          shuffleArray(letterBag);
          playerHand = [];
          refillHand();
          showMessage("Letras trocadas!", 1500); // Movido para depois de refillHand
          checkGameOver(); // Movido para depois de refillHand e showMessage
          renderStats(); // Para atualizar o estado da energia imediatamente
        }

        function sortHandAlpha() {
          if (!gameActive) return;
          playerHand.sort((a, b) =>
            a && b ? a.letter.localeCompare(b.letter) : 0
          );
          renderHand();
        }

        function checkGameOver() {
          if (currentEnergy <= 0) {
            gameActive = false;
            finalScoreElement.textContent = totalScore;
            gameOverPopup.classList.remove("hidden");
            showMessage("Fim de Jogo!", 3000);
            renderStats();
          }
        }

        function initializeGame() {
          gameActive = true;
          currentEnergy = INITIAL_ENERGY;
          totalScore = 0;
          currentWordPoints = 0;
          currentWordMultis = 0;
          targetScore = 60;
          // scoreTargetValueElement.textContent = targetScore; // Será chamado por renderStats

          createLetterBag();
          playerHand = [];
          boardState.fill(null);
          refillHand();
          gameOverPopup.classList.add("hidden");
          document.getElementById("swap-cost").textContent = `${SWAP_COST}⚡`;
          renderBoard(); // Isso chama calculateAndUpdateWordScore que chama renderStats
        }

        function handleDragStartHandLetter(event) {
          if (!gameActive) {
            event.preventDefault();
            return;
          }
          event.target.classList.add("dragging");
          draggedLetterInfo = {
            letter: event.target.dataset.letter,
            id: event.target.dataset.handId,
            origin: "hand",
            element: event.target,
          };
          event.dataTransfer.effectAllowed = "move";
          event.dataTransfer.setData("text/plain", event.target.dataset.handId);
        }
        function handleDragStartBoardLetter(event) {
          if (!gameActive) {
            event.preventDefault();
            return;
          }
          const slotElement = event.target.closest(".board-slot.has-letter");
          if (!slotElement) return;
          const boardIndex = parseInt(slotElement.dataset.index);
          const letterOnBoard = boardState[boardIndex];
          if (!letterOnBoard) return;
          slotElement.classList.add("dragging");
          draggedLetterInfo = {
            ...letterOnBoard,
            origin: "board",
            boardIndex: boardIndex,
            element: slotElement,
          };
          event.dataTransfer.effectAllowed = "move";
          event.dataTransfer.setData("text/plain", letterOnBoard.id);
        }
        function handleDragEndLetter(event) {
          if (draggedLetterInfo && draggedLetterInfo.element)
            draggedLetterInfo.element.classList.remove("dragging");
          draggedLetterInfo = null;
          document
            .querySelectorAll(".drag-over")
            .forEach((el) => el.classList.remove("drag-over"));
        }
        function handleDragOver(event) {
          event.preventDefault();
          event.dataTransfer.dropEffect = "move";
        }
        function handleDragEnter(event) {
          event.preventDefault();
          const target = event.target.closest(".board-slot, #player-hand");
          if (target) {
            if (
              draggedLetterInfo &&
              draggedLetterInfo.origin === "board" &&
              target.classList.contains("board-slot") &&
              parseInt(target.dataset.index) === draggedLetterInfo.boardIndex
            )
              return;
            target.classList.add("drag-over");
          }
        }
        function handleDragLeave(event) {
          const target = event.target.closest(".board-slot, #player-hand");
          if (target) target.classList.remove("drag-over");
        }
        function handleDropOnBoardSlot(event) {
          event.preventDefault();
          if (!gameActive || !draggedLetterInfo) return;
          const targetSlotElement = event.target.closest(".board-slot");
          if (!targetSlotElement) return;
          targetSlotElement.classList.remove("drag-over");
          const targetSlotIndex = parseInt(targetSlotElement.dataset.index);
          const existingLetterInTarget = boardState[targetSlotIndex];

          if (draggedLetterInfo.origin === "hand") {
            if (!existingLetterInTarget) {
              boardState[targetSlotIndex] = {
                letter: draggedLetterInfo.letter,
                id: draggedLetterInfo.id,
              };
              playerHand = playerHand.filter(
                (tile) => tile.id !== draggedLetterInfo.id
              );
            } else {
              const letterToHand = boardState[targetSlotIndex];
              boardState[targetSlotIndex] = {
                letter: draggedLetterInfo.letter,
                id: draggedLetterInfo.id,
              };
              playerHand = playerHand.filter(
                (tile) => tile.id !== draggedLetterInfo.id
              );
              playerHand.push(letterToHand);
            }
          } else if (draggedLetterInfo.origin === "board") {
            if (draggedLetterInfo.boardIndex === targetSlotIndex) return;
            if (!existingLetterInTarget) {
              boardState[targetSlotIndex] =
                boardState[draggedLetterInfo.boardIndex];
              boardState[draggedLetterInfo.boardIndex] = null;
            } else {
              const temp = boardState[targetSlotIndex];
              boardState[targetSlotIndex] =
                boardState[draggedLetterInfo.boardIndex];
              boardState[draggedLetterInfo.boardIndex] = temp;
            }
          }
          renderBoard();
          renderHand();
          draggedLetterInfo = null;
        }
        function handleDropOnPlayerHand(event) {
          event.preventDefault();
          if (
            !gameActive ||
            !draggedLetterInfo ||
            draggedLetterInfo.origin !== "board"
          )
            return;
          playerHandElement.classList.remove("drag-over");
          const letterData = boardState[draggedLetterInfo.boardIndex];
          if (letterData) {
            playerHand.push(letterData);
            boardState[draggedLetterInfo.boardIndex] = null;
            renderBoard();
            renderHand();
          }
          draggedLetterInfo = null;
        }

        playButton.addEventListener("click", handlePlayWord);
        swapLettersButton.addEventListener("click", handleSwapLetters);
        clearWordButton.addEventListener("click", clearWordFromBoard);
        sortAlphaButton.addEventListener("click", sortHandAlpha);
        restartButton.addEventListener("click", initializeGame);
        menuButton.addEventListener("click", () =>
          showMessage("Menu não implementado.", 1500)
        );

        playerHandElement.addEventListener("dragover", handleDragOver);
        playerHandElement.addEventListener("dragenter", handleDragEnter);
        playerHandElement.addEventListener("dragleave", handleDragLeave);
        playerHandElement.addEventListener("drop", handleDropOnPlayerHand);

        initializeGame();
      });
    </script>
  </body>
</html>
